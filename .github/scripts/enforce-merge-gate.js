/**
 * Enforce Merge Gate
 * Blocks merges that don't meet quality thresholds
 */

const core = require('@actions/core');
const github = require('@actions/github');
const fs = require('fs');

// Configuration
const MERGE_THRESHOLD = parseInt(process.env.MERGE_THRESHOLD || '80');
const STRICT_MODE = process.env.STRICT_MODE === 'true';

async function loadReadinessScore() {
  // First try to get from environment variable (set by previous step)
  if (process.env.READINESS_SCORE) {
    return parseInt(process.env.READINESS_SCORE);
  }

  // Try to load from readiness report
  if (fs.existsSync('readiness-report.json')) {
    const report = JSON.parse(fs.readFileSync('readiness-report.json', 'utf8'));
    return report.score;
  }

  // Run calculation if needed
  const { calculateReadinessScore } = require('./calculate-readiness');
  const prData = JSON.parse(fs.readFileSync('dashboard-data.json', 'utf8'));
  const result = calculateReadinessScore(prData, null);
  return result.total;
}

function generateIssuesList(report) {
  const issues = [];

  if (report.breakdown) {
    if (report.breakdown.coverage < 80) {
      issues.push(`❌ Coverage is ${report.prData?.coverage?.toFixed(1) || 0}% (minimum 80%)`);
    }
    if (report.breakdown.tests < 100) {
      issues.push(`❌ Test pass rate is below 100% (${report.prData?.tests || 'N/A'})`);
    }
    if (report.breakdown.security < 80) {
      issues.push(`❌ Security score is ${report.prData?.security || 0}/100 (minimum 80)`);
    }
    if (report.breakdown.codeQuality < 100) {
      issues.push(`⚠️ Code quality issues detected`);
    }
  }

  if (issues.length === 0) {
    issues.push('✅ All checks passed');
  }

  return issues.join('\n');
}

async function createGitHubComment(octokit, score, report) {
  const context = github.context;

  if (!context.issue.number) {
    console.log('No PR number found in context, skipping comment');
    return;
  }

  const isPassing = score >= MERGE_THRESHOLD;
  const emoji = isPassing ? '✅' : '❌';
  const title = isPassing ? 'Merge Requirements Met' : 'Merge Blocked';

  const commentBody = `## ${emoji} ${title}

**Readiness Score: ${score}%** (threshold: ${MERGE_THRESHOLD}%)

### 📊 Score Breakdown

| Metric | Score | Weight | Contribution |
|--------|-------|--------|--------------|
| Coverage | ${report.breakdown.coverage.toFixed(1)}% | ${report.weights.coverage} | ${(report.breakdown.coverage * report.weights.coverage).toFixed(1)}% |
| Tests | ${report.breakdown.tests.toFixed(1)}% | ${report.weights.tests} | ${(report.breakdown.tests * report.weights.tests).toFixed(1)}% |
| Security | ${report.breakdown.security.toFixed(1)}% | ${report.weights.security} | ${(report.breakdown.security * report.weights.security).toFixed(1)}% |
| Code Quality | ${report.breakdown.codeQuality.toFixed(1)}% | ${report.weights.codeQuality} | ${(report.breakdown.codeQuality * report.weights.codeQuality).toFixed(1)}% |

### ${isPassing ? '✅ Status' : '❌ Issues to Address'}

${generateIssuesList(report)}

${!isPassing ? `
### 🔧 How to Improve

1. **Increase test coverage** to at least 80%
   - Add unit tests for uncovered functions
   - Include edge cases in your tests

2. **Fix failing tests**
   - Review test failures in the CI logs
   - Update tests if the implementation changed

3. **Resolve security vulnerabilities**
   - Run \`npm audit fix\` for JavaScript dependencies
   - Update vulnerable packages to secure versions

4. **Fix linting/build errors**
   - Ensure the build passes without errors
   - Address all linting warnings

Re-run the checks after making improvements.` : ''}

### 🎯 Readiness Level: ${report.level}

${score >= 90 ? '🎉 **Excellent** - This PR exceeds quality standards!' :
  score >= 80 ? '✅ **Good** - This PR meets quality standards and is ready to merge.' :
  score >= 70 ? '⚠️ **Acceptable** - This PR barely meets minimum standards. Consider improvements.' :
  score >= 60 ? '🔧 **Needs Work** - This PR requires significant improvements before merging.' :
  '❌ **Not Ready** - This PR does not meet minimum quality standards.'}

---
*Generated by Trinity Dashboard Merge Gate | [View Dashboard](https://your-dashboard-url.com/pr/${context.issue.number})*`;

  try {
    // Find existing comment
    const comments = await octokit.rest.issues.listComments({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: context.issue.number
    });

    const botComment = comments.data.find(comment =>
      comment.body.includes('Readiness Score:') &&
      comment.body.includes('Generated by Trinity Dashboard')
    );

    if (botComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        comment_id: botComment.id,
        body: commentBody
      });
    } else {
      // Create new comment
      await octokit.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: context.issue.number,
        body: commentBody
      });
    }

    console.log(`GitHub comment ${botComment ? 'updated' : 'created'} successfully`);
  } catch (error) {
    console.error('Failed to create/update GitHub comment:', error.message);
  }
}

async function createCheckRun(octokit, score, report) {
  const context = github.context;

  if (!context.sha) {
    console.log('No SHA found in context, skipping check run');
    return;
  }

  const isPassing = score >= MERGE_THRESHOLD;

  try {
    await octokit.rest.checks.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      name: 'Merge Readiness Gate',
      head_sha: context.sha,
      status: 'completed',
      conclusion: isPassing ? 'success' : 'failure',
      output: {
        title: `Readiness Score: ${score}%`,
        summary: `This PR ${isPassing ? 'meets' : 'does not meet'} the merge readiness threshold of ${MERGE_THRESHOLD}%.

**Score Breakdown:**
- Coverage: ${report.breakdown.coverage.toFixed(1)}%
- Tests: ${report.breakdown.tests.toFixed(1)}%
- Security: ${report.breakdown.security.toFixed(1)}%
- Code Quality: ${report.breakdown.codeQuality.toFixed(1)}%`,
        text: generateIssuesList(report)
      }
    });

    console.log('GitHub check run created successfully');
  } catch (error) {
    console.error('Failed to create check run:', error.message);
  }
}

async function enforceMergeGate() {
  try {
    // Load readiness score
    const readinessScore = await loadReadinessScore();
    console.log(`Readiness Score: ${readinessScore}%`);
    console.log(`Merge Threshold: ${MERGE_THRESHOLD}%`);

    // Load full report if available
    let report = { breakdown: {}, weights: {}, prData: {} };
    if (fs.existsSync('readiness-report.json')) {
      report = JSON.parse(fs.readFileSync('readiness-report.json', 'utf8'));
    }

    // Check if score meets threshold
    const meetsThreshold = readinessScore >= MERGE_THRESHOLD;

    if (!meetsThreshold) {
      // Set as failed
      core.setFailed(
        `Merge blocked: Readiness score ${readinessScore}% is below threshold of ${MERGE_THRESHOLD}%`
      );

      console.log('');
      console.log('=== MERGE BLOCKED ===');
      console.log(`This PR cannot be merged because the readiness score is ${readinessScore}%`);
      console.log(`The minimum required score is ${MERGE_THRESHOLD}%`);
      console.log('');
      console.log('Issues to address:');
      console.log(generateIssuesList(report));
    } else {
      console.log('');
      console.log('=== MERGE ALLOWED ===');
      console.log(`✅ Readiness score ${readinessScore}% meets the threshold of ${MERGE_THRESHOLD}%`);
      core.info(`✅ Merge allowed: Readiness score ${readinessScore}% meets threshold`);
    }

    // Create GitHub comment and check run if token is available
    if (process.env.GITHUB_TOKEN) {
      const octokit = github.getOctokit(process.env.GITHUB_TOKEN);
      await createGitHubComment(octokit, readinessScore, report);
      await createCheckRun(octokit, readinessScore, report);
    }

    // Output for other steps
    core.setOutput('readiness_score', readinessScore);
    core.setOutput('meets_threshold', meetsThreshold);
    core.setOutput('threshold', MERGE_THRESHOLD);

    // In strict mode, always fail if below threshold
    if (STRICT_MODE && !meetsThreshold) {
      process.exit(1);
    }

  } catch (error) {
    console.error('Error enforcing merge gate:', error);
    core.setFailed(`Error enforcing merge gate: ${error.message}`);
    process.exit(1);
  }
}

// Run if executed directly
if (require.main === module) {
  enforceMergeGate();
}

module.exports = { enforceMergeGate };